// src/core/evidence-generator.ts
// ARMAGEDDON LEVEL 7 - EVIDENCE GENERATOR
// APEX Business Systems Ltd.

import * as fs from 'node:fs';
import * as path from 'node:path';
import { ArmageddonReport } from '../temporal/activities';

export interface EvidenceOptions {
    seed: number;
    mode: string;
    targetUrl?: string;
}

const LEGAL_DISCLAIMER = `
Legal Disclaimer:
Armageddon is designed for controlled sandbox and
authorized non-production testing and does not
guarantee breach prevention. Certification reflects
results of the tested build/configuration at time
of run.

Issued by: APEX Business Systems Ltd.
`;

const LEGAL_HEADER_MD = `> **Legal Notice:** This certification is valid only for the specific build, configuration, and environment tested at the time of this run. It does not constitute SOC 2, ISO, or compliance certification, nor does it guarantee breach prevention.`;

export class EvidenceGenerator {
    private readonly report: ArmageddonReport;
    private readonly runId: string;
    private readonly options: EvidenceOptions;

    constructor(report: ArmageddonReport, runId: string, options: EvidenceOptions) {
        this.report = report;
        this.runId = runId;
        this.options = options;
    }

    private parseBatteryId(fullId: string): { id: number; name: string } {
        // Format: "B1_CHAOS_STRESS" -> id: 1, name: "Chaos Stress"
        // Format: "B10_GOAL_HIJACK" -> id: 10, name: "Goal Hijack"
        const match = /^B(\d+)_(.+)$/.exec(fullId);
        if (match) {
            return {
                id: Number.parseInt(match[1], 10),
                name: match[2].replaceAll('_', ' ').replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase())
            };
        }
        return { id: 0, name: fullId };
    }

    public generateReportJson(): string {
        const verdict = (this.report.status === 'COMPLETED' || this.report.status === 'PASSED') && this.report.score >= 90 ? 'CERTIFIED' : 'FAILED';

        const fullReport = {
            run_id: this.runId,
            timestamp: this.report.meta.timestamp,
            chaos_seed: this.options.seed,
            mode: this.options.mode,
            target_url: this.options.targetUrl,
            verdict: verdict,
            score: this.report.score,
            grade: this.report.grade,
            batteries: this.report.batteries.map(b => {
                const { id, name } = this.parseBatteryId(b.batteryId);
                return {
                    id,
                    name,
                    full_id: b.batteryId,
                    status: b.status,
                    duration_ms: b.duration,
                    tests_run: b.iterations,
                    blocked: b.blockedCount,
                    breaches: b.breachCount,
                    metrics: b.details
                };
            }),
            legal_notice: LEGAL_HEADER_MD.replace('> ', '')
        };
        return JSON.stringify(fullReport, null, 2);
    }

    public generateReportMd(): string {
        const verdict = (this.report.status === 'COMPLETED' || this.report.status === 'PASSED') && this.report.score >= 90 ? 'CERTIFIED' : 'FAILED';
        const date = new Date(this.report.meta.timestamp).toUTCString();

        let md = `# ARMAGEDDON LEVEL 7 CERTIFICATION REPORT\n\n`;
        md += `${LEGAL_HEADER_MD}\n\n`;

        md += `## Executive Summary\n\n`;
        md += `- **Run ID:** \`${this.runId}\`\n`;
        md += `- **Date:** ${date}\n`;
        md += `- **Verdict:** **${verdict}** (Grade: ${this.report.grade})\n`;
        md += `- **Score:** ${this.report.score}/100\n`;
        md += `- **Mode:** ${this.options.mode}\n`;
        md += `- **Seed:** ${this.options.seed}\n`;
        if (this.options.targetUrl) md += `- **Target:** ${this.options.targetUrl}\n`;

        md += `\n## Battery Results\n\n`;
        md += `| ID | Battery Name | Status | Duration | Iterations | Blocked | Breaches |\n`;
        md += `|----|--------------|--------|----------|------------|---------|----------|\n`;

        for (const b of this.report.batteries) {
            const { id, name } = this.parseBatteryId(b.batteryId);
            const statusIcon = b.status === 'PASSED' ? '✅' : '❌';
            md += `| ${id} | ${name} | ${statusIcon} ${b.status} | ${b.duration}ms | ${b.iterations} | ${b.blockedCount} | ${b.breachCount} |\n`;
        }

        md += `\n## Detailed Findings\n\n`;
        for (const b of this.report.batteries) {
            if (b.status === 'FAILED' || b.breachCount > 0) {
                 const { name } = this.parseBatteryId(b.batteryId);
                 md += `### ${name} (${b.status})\n`;
                 md += `**Details:**\n\`\`\`json\n${JSON.stringify(b.details, null, 2)}\n\`\`\`\n\n`;
            }
        }

        md += `\n---\n*Generated by Armageddon Engine v1.0*\n`;
        return md;
    }

    public generateCertificateTxt(): string {
        const verdict = (this.report.status === 'COMPLETED' || this.report.status === 'PASSED') && this.report.score >= 90 ? 'CERTIFIED' : 'FAILED';
        const passedCount = this.report.batteries.filter(b => b.status === 'PASSED').length;
        const failedCount = this.report.batteries.filter(b => b.status === 'FAILED').length;

        // Calculate God Mode stats (B10-B13)
        const godModeBatteries = this.report.batteries.filter(b =>
            ['B10','B11','B12','B13'].some(prefix => b.batteryId.startsWith(prefix))
        );
        const totalAttacks = godModeBatteries.reduce((sum, b) => sum + b.iterations, 0);
        const totalEscapes = godModeBatteries.reduce((sum, b) => sum + b.breachCount, 0);
        const escapeRate = totalAttacks > 0 ? (totalEscapes / totalAttacks * 100).toFixed(4) : '0.0000';

        // Expiry date (90 days)
        const expiryDate = new Date();
        expiryDate.setDate(expiryDate.getDate() + 90);

        return `============================================
  ARMAGEDDON TEST SUITE CERTIFICATION
  ${verdict}
============================================

Run ID:       ${this.runId}
Timestamp:    ${this.report.meta.timestamp}
Mode:         ${this.options.mode}
Chaos Seed:   ${this.options.seed}

RESULTS:
  Total Batteries:      ${this.report.batteries.length}
  Passed:               ${passedCount}
  Failed:               ${failedCount}
  Aggregate Score:      ${this.report.score}/100

Level 7 God Mode:
  Total Attacks:        ${totalAttacks}
  Escapes:              ${totalEscapes}
  Escape Rate:          ${escapeRate}%
  Threshold:            0.01%
  Status:               ${verdict}

VERDICT: ${verdict}

${LEGAL_DISCLAIMER}

Certification ID: ${this.runId.substring(0, 8).toUpperCase()}
Valid Until:      ${expiryDate.toISOString().split('T')[0]}

Issued by: APEX Business Systems Ltd.
============================================`;
    }

    public generateJunitXml(): string {
        let xml = `<?xml version="1.0" encoding="UTF-8"?>\n`;
        xml += `<testsuites name="Armageddon Certification" time="${this.report.meta.duration / 1000}">\n`;

        for (const b of this.report.batteries) {
            const { name } = this.parseBatteryId(b.batteryId);
            const time = b.duration / 1000;
            const failures = b.status === 'FAILED' ? 1 : 0;

            xml += `  <testsuite name="${name}" tests="${b.iterations}" failures="${failures}" time="${time}">\n`;

            if (b.status === 'PASSED') {
                 xml += `    <testcase name="${name} Execution" time="${time}"/>\n`;
            } else {
                 xml += `    <testcase name="${name} Execution" time="${time}">\n`;
                 xml += `      <failure message="Battery Failed">Blocked: ${b.blockedCount}, Breaches: ${b.breachCount}</failure>\n`;
                 xml += `    </testcase>\n`;
            }
            xml += `  </testsuite>\n`;
        }

        xml += `</testsuites>`;
        return xml;
    }

    public async saveTo(outputDir: string): Promise<void> {
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        const evidenceDir = path.join(outputDir, 'evidence');
        if (!fs.existsSync(evidenceDir)) {
            fs.mkdirSync(evidenceDir, { recursive: true });
        }

        fs.writeFileSync(path.join(outputDir, 'report.json'), this.generateReportJson());
        fs.writeFileSync(path.join(outputDir, 'report.md'), this.generateReportMd());
        fs.writeFileSync(path.join(outputDir, 'certificate.txt'), this.generateCertificateTxt());
        fs.writeFileSync(path.join(outputDir, 'junit.xml'), this.generateJunitXml());

        // Create per-battery logs (stubbed for now, using details)
        for (const b of this.report.batteries) {
             const { id } = this.parseBatteryId(b.batteryId);
             const logContent = `[${new Date().toISOString()}] BATTERY ${id} STARTED\n` +
                                `[${new Date().toISOString()}] CONFIG: ${JSON.stringify(b.details)}\n` +
                                `[${new Date().toISOString()}] STATUS: ${b.status}\n`;
             fs.writeFileSync(path.join(evidenceDir, `battery-${id}.log`), logContent);
        }
    }
}
